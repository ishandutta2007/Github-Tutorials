How to Read Open Source Software Code in the "Right Way"
===

> All articles that tell you to directly read the latest source code are talking nonsense. You should start reading the code from "a certain version."

We don't recommend that all readers directly dive into the latest code. The right approach should be:

- Clone a project's code to your local machine.
- Check the project's release list.
- Find a release version that you can understand, such as version 1.0 or an earlier version.
- Understand the code of that previous version.
- Move forward and read the source code of major versions.
- Finally, read the latest source code.

It's best if **you can reimplement (build a wheel)** during this process.

## Reading Process

In my experience reading front-end libraries and Python back-end libraries, we always proceeded with the goal of building a wheel. So, at the very beginning, I needed a working version that had the features I wanted.

![it-works-cms.png](../img/it-works-cms.png)

Immediately afterward, I could start experimenting with some of the features in that version and understanding how they work. Then, using `git`, I could review the changes made before, using an IDE's built-in Diff tool:

![pycharm-diff.jpg](../img/pycharm-diff.jpg)

Or tools like `SourceTree` to see the modifications.

After understanding the basic core functionalities, we can then move forward to review the updates in major and medium versions.

Before we start, we hope everyone has some basic understanding of version number management.

## Version Number Management

The first open-source software I read was Linux, and below is Linux's release process:

![linux-history.png](../img/linux-history.png)

The table is from a book called "Linux Kernel 0.11 (0.95) Complete Annotation." Let's briefly introduce it:

- Version 0.00 was a hello, world program.
- Version 0.01 contained working code.
- Version 0.11 was a basically functional version.

This leads to the "GNU-style Version Number Management Strategy":

1.  When the project first starts, the version number can be 0.1 or 0.1.0, or 1.0 or 1.0.0. If you're very humble, you might choose the one starting with main version 0.
2.  When the project undergoes minor modifications or bug fixes, the main and sub-version numbers remain unchanged; the revision version number increments by 1.
3.  When the project adds some features on the existing basis, the main version number stays the same, the sub-version number increases by 1, and the revision version resets to 0, which can be ignored.
4.  When the project undergoes major modifications or accumulates many minor fixes, causing a significant global change to the project, the main version number increases by 1.
5.  Additionally, the build version number is usually automatically generated by the compiler during compilation. We only define its format and do not control it manually.

Therefore, we can draw a few simple conclusions:

- We need to read the earliest version that contains the core code.
- We need to read the 1.0 release version.
- We should understand every major release afterward.

## Example

Taking Flask as an example:

First, clone it.

![clone-flask.png](../img/clone-flask.png)

Second, find its early versions from the Releases page:

![flask.png](../img/flask.png)

Third, get its commit hash `8605cc3` from above, then checkout to that commit to examine its features. In this version, there are just over six hundred lines of code.

![flask-0.1.png](../img/flask-0.1.png)

Still a bit long.

Fourth, we can find its earliest version:

![flask-init.png](../img/flask-init.png)

Then look at its `flask.py` file. It has only a simple three hundred or so lines, including many comments:

![flask-init.png](../img/flask-init.png)

Fifth, then, go back and read:

- Version 0.1
- ...
- The latest version, 0.10.1